# Методы
1. [Использование методов в программе](#Использование-методов-в-программе)
2. [Передача параметров в методы](#Передача-параметров-в-методы)
3. [Параметры переменной длины](#Параметры-переменной-длины)
4. [Оператор `return`](#Оператор-return)
5. [Перегрузка методов](#Перегрузка-методов)
6. [Рекурсивные функции](#Рекурсивные-функции)

## Использование методов в программе
Если *переменные* и *константы* хранят некоторые значения, то *методы* содержат собой набор операторов, которые выполняют определенные действия.

Общее определение методов выглядит следующим образом:
```java
[модификаторы] тип_возвращаемого_значения название_метода ([параметры]){
    // тело метода
}
```

Модификаторы и параметры необязательны.

По умолчанию главный класс любой программы на **Java** содержит метод `main`, который *служит точкой входа в программу*:
```java
public static void main(String[] args) {
    System.out.println("привет мир!");
}
```

Ключевые слова `public` и `static` являются *модификаторами*. Далее идет *тип возвращаемого значения*. Ключевое слово `void` указывает на то, что метод ничего не возвращает.

Затем идут *название метода* - `main` и в скобках *параметры метода* - `String[] args`. И в фигурные скобки заключено *тело метода* - все действия, которые он выполняет.

Создадим еще несколько методов:
```java
public class Program {
    public static void main(String args[]) {
          
    }

    void hello() {     
        System.out.println("Hello");
    }

    void welcome() {     
        System.out.println("Welcome to Java 10");
    }
}
```

Здесь определены два дополнительных метода: `hello` и `welcome`, каждый из которых выводит некоторую строку на консоль. Методы определяются внутри класса - в данном случае внутри класса `Program`, в котором определен метод `main`.

Но если мы скомпилируем и запустим данную программу, то мы ничего не увидим на консоли. В примере выше мы определили два метода, но мы их нигде не вызываем. По умолчанию в программе **Java** выполняется только метод `main` и все его содержимое. Поэтому, если мы хотим, чтобы другие методы тоже выполнялись, их надо вызвать в методе `main`.

Вызов метода осуществляется в форме:
```java
имя_метода(аргументы);
```

После *имени метода* указываются скобки, в которых перечисляются *аргументы* - значения для параметров метода.

Например, определим и выполним несколько методов:
```java
public class Program {
    public static void main(String args[]) {
         hello();
         welcome();
         welcome();
    }

    static void hello() {
        System.out.println("Hello");
    }

    static void welcome() {
        System.out.println("Welcome to Java 10");
    }
}
```

В методе `main` вызывается один раз метод `hello` и два раза метод `welcome`. В этом и заключается одно из преимуществ методов: мы можем вынести некоторые общие действия в отдельный метод и затем вызывать многократно их в различных местах программы. Поскольку оба метода не имеют никаких параметров, то после их названия при вызове ставятся пустые скобки.

Также следует отметить, что чтобы вызвать в методе `main` другие методы, которые определены в одном классе с методом `main`, они должны иметь *модификатор* `static`.

В итоге после компиляции и выполнения программы мы увидим на консоли:

![](images/console-output-methods.png)


## Передача параметров в методы
С помощью параметров мы можем передать в методы различные данные, которые будут использоваться для вычислений. Например:
```java
static void sum(int x, int y) {
    int z = x + y;
    System.out.println(z);
}
```

Данная функция принимает два параметра - два числа, складывает их и выводит их сумму на консоль.

А при вызове этого метода в программе нам необходимо передать на место параметров значения, которые соответствуют типу параметра:
```java
public class Program {
    public static void main(String args[]) {
        int a = 6;
        int b = 8;
        sum(a, b);  // 14
        sum(3, a);  // 9
        sum(5, 23); // 28
    }

    static void sum(int x, int y) {
        int z = x + y;
        System.out.println(z);
    }
}
```

Поскольку метод `sum` принимает два значения типа `int`, то на место параметров надо передать два значения типа `int`. Это могут быть и числовые литералы, и переменные типов данных, которые представляют тип `int` или могут быть автоматически преобразованы в тип `int`. Значения, которые передаются на место параметров, еще называются аргументами. Значения передаются параметрам по позиции, то есть первый аргумент первому параметру, второй аргумент - второму параметру и так далее.

Рассмотрим другой пример:
```java
public class Program {
    public static void main(String args[]) {
        display("Tom", 34);
        display("Bob", 28);
        display("Sam", 23);
    }

    static void display(String name, int age) {
        System.out.println(name);
        System.out.println(age);
    }
}
```

Метод `display` принимает два параметра. Первый параметр представляет тип `String`, а второй - тип `int`. Поэтому при вызове метода вначале в него надо передать строку, а затем число.

## Параметры переменной длины
Метод может принимать параметры переменной длины одного типа. Например, нам надо передать в метод набор числел и ычислить их сумму, но мы точно не знаем, сколько именно чисел будет передано - 3, 4, 5 или больше. Параметры переменной длины позволяют решить эту задачу:
```java
public class Program {
    public static void main(String args[]) {
        sum(1, 2, 3);           // 6
        sum(1, 2, 3, 4, 5);     // 15
        sum();                  // 0
    }

    static void sum(int ...nums) {
        int result = 0;
        for (int n : nums) {
            result += n;
        }
        System.out.println(result);
    }
}
```

Троеточие перед названием параметра `int ...nums` указывает на то, что он будет необязательным и будет представлять массив. Мы можем передать в метод `sum` одно число, несколько чисел, а можем вообще не передавать никаких параметров. Причем, если мы хотим передать несколько параметров, то необязательный параметр должен указываться в конце:
```java
public static void main(String[] args) {  
    sum("Welcome!", 20, 10);
    sum("Hello World!");
}

static void sum(String message, int ...nums) {
    System.out.println(message);   
    int result = 0;
    for (int x: nums) {
        result += x;
    }
    System.out.println(result);
}
```

## Оператор `return`
Методы могут возвращать некоторое значение. Для этого применяется оператор `return`.
```java
return возвращаемое_значение;
```

После оператора `return` указывается возвращаемое значение, которое является результатом метода. Это может быть литеральное значение, значение переменной или какого-то сложного выражения.

Например:
```java
public class Program {
    public static void main(String args[]) {
        int x = sum(1, 2, 3);
        int y = sum(1, 4, 9);
        System.out.println(x);  // 6
        System.out.println(y);  // 14
    }

    static int sum(int a, int b, int c) {
        return a + b + c;
    }
}
```

В методе в качестве типа возвращаемого значения вместо `void` используется любой другой тип. В данном случае метод sum возвращает значение типа `int`, поэтому этот тип указывается перед названием метода. Причем если в качестве возвращаемого типа для метода определен любой другой, отличный от `void`, то метод обязательно должен использовать оператор `return` для возвращения значения.

При этом возвращаемое значение всегда должно иметь тот же тип, что значится в определении функции. И если функция возвращает значение типа `int`, то после оператора `return` стоит целочисленное значение, которое является объектом типа `int`. Как в данном случае это сумма значений параметров метода.

Метод может использовать несколько вызовов оператора `return` для возваращения разных значений в зависимости от некоторых условий:
```java
public class Program {
    public static void main(String args[]) {
        System.out.println(daytime(7));     // Good morning
        System.out.println(daytime(13));    // Good after noon
        System.out.println(daytime(18));    // Good evening
        System.out.println(daytime(2));     // Good night
    }

    static String daytime(int hour) {
        if (hour >24 || hour < 0) {
            return "Invalid data";
        } else if(hour > 21 || hour < 6) {
            return "Good night";
        } else if(hour >= 15) {
            return "Good evening";
        } else if(hour >= 11) {
            return "Good after noon";
        } else {
            return "Good morning";
        }
    }
}
```

Здесь метод `daytime` возвращает значение типа `String`, то есть строку, и в зависимости от значения параметра `hour` возвращаемая строка будет различаться.

### Выход из метода
Оператор `return` применяется для возвращаения значения из метода, но и для выхода из метода. В подобном качестве оператор `return` применяется в методах, которые ничего не возвращают, то есть имеют тип `void`:
```java
public class Program {
    public static void main(String args[]) {
        daytime(7);     // Good morning
        daytime(13);    // Good after noon
        daytime(32);    // 
        daytime(56);    // 
        daytime(2);     // Good night
    }

    static void daytime(int hour) {
        if (hour >24 || hour < 0) {
            return;
        } else if(hour > 21 || hour < 6) {
            System.out.println("Good night");
        } else if(hour >= 15) {
            System.out.println("Good evening");
        } else if(hour >= 11) {
            System.out.println("Good after noon");
        } else {
            System.out.println("Good morning");
        }   
    }
}
```

Если переданное в метод `datetime` значение больше `24` или меньше `0`, то просто выходим из метода. Возвращаемое значение после `return` указывать в этом случае не нужно.


## Перегрузка методов
В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров. Такой механизм называется **перегрузкой методов** (method overloading).

Например:
```java
public class Program{
      
    public static void main(String[] args) {
         
        System.out.println(sum(2, 3));          // 5
        System.out.println(sum(4.5, 3.2));      // 7.7
        System.out.println(sum(4, 3, 7));       // 14
    }
    static int sum(int x, int y){
             
        return x + y;
    }
    static double sum(double x, double y){
             
        return x + y;
    }
    static int sum(int x, int y, int z){
             
        return x + y + z;
    }
}
```

Здесь определено три варианта или три перегрузки метода `sum()`, но при его вызове в зависимости от типа и количества передаваемых параметров система выберет именно ту версию, которая наиболее подходит.

Стоит отметить, что на перегрузку методов влияют количество и типы параметров. Однако различие в типе возвращаемого значения для перегрузки не имеют никакого значения. Например, в следующем случае методы различаются по типу возвращаемого значения:
```java
public class Program {
    public static void main(String[] args) {
        System.out.println(sum(2, 3));
        System.out.println(sum(4, 3));
    }

    static int sum(int x, int y) {
        return x + y;
    }

    static double sum(int x, int y) {
        return x + y;
    }
}
```

Однако перегрузкой это не будет считаться. Более того такая программа некорректна и попросту не скомилируется, так как метод с одним и тем же количеством и типом параметров определен несколько раз.


## Рекурсивные функции
Отдельно рассмотрим рекурсивные функции. Главное отличие рекурсивных функций от обычных методов состоит в том, что они рекурсивная функция может вызывать саму себя.

Например, рассмотрим функцию, которая вычисляет факториал числа:
```java
static int factorial(int x){
     
    if (x == 1){
     
        return 1;
    }
    return x * factorial(x - 1);
}
```

Вначале проверяется условие: если вводимое число не равно `1`, то мы умножаем данное число на результат этой же функции, в которую в качестве параметра передается число `x-1`. То есть происходит *рекурсивный спуск*. И так дальше, пока не дойдем того момента, когда значение параметра не будет равно `1`.

Рекурсивная функция обязательно должна иметь некоторый *базовый вариант*, который использует оператор `return` и который помещается в начале функции. В случае с факториалом это `if (x == 0) return 1;`. И все рекурсивные вызовы должны обращаться к подфункциям, которые в конечном счете сходятся к базовому варианту. Так, при передаче в функцию положительного числа при дальнейших рекурсивных вызовах подфункций в них будет передаваться каждый раз число, меньшее на единицу. И в конце концов мы дойдем до ситуации, когда число будет равно `0`, и будет использован базовый вариант.

Хотя в данном случае нужно отметить, что для определения факториала есть более оптимальные решения на основе циклов:
```java
static int factorial(int x) {
    int result = 1;
    for (int i = 1; i <= x; i++)
    {
        result *= i;
    }
    return result;
}
```

Еще одним распространенным примером рекурсивной функции служит функция, вычисляющая *числа Фибоначчи*. В теории n-й член последовательности Фибоначчи определяется по формуле: `f(n)=f(n-1) + f(n-2)`, причем `f(0)=0`, а `f(1)=1`.
```java
static int fibonachi(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonachi(n - 1) + fibonachi(n - 2);
    }
}