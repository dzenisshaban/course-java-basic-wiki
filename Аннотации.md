## Аннотации
**Аннотация** - средство, что позволяет встроить информацию поддержки в исходные файлы, то есть аннотации можно использовать для отслеживания ошибок, устранения предупреждений, генерации кода, *XML* файлов.


### Встроенные аннотации
В Java определено много полезных встроенных аннотаций, большинство из их являются специализированными. Аннотации, что имеют общее назначение:
- `@Retention` - эта аннотация предназначена для применения только в качестве аннотации к другим аннотациям. Определяет политику удержания
- `@Documented` - это маркер-интерфейс, который сообщает инструменту, что аннотация должна быть документирована
- `@Target` - эта аннотация задает тип объявления, к которым может быть применима аннотация. Принимает один аргумент, который должен быть константой из перечисления `ElementType`
- `@Inherited` - это аннотация-маркер, которая может применяться в другом объявление аннотации, она касается только тех аннотаций, что будут использованы в объявлениях классов. Эта аннотация позволяет аннотации супер класса быть унаследованной в подклассе
- `@Override` - аннотация-маркер, которая может применяться только к методам. Метод, аннотированный как `@Override`, должен переопределять метод супер класса
- `@Deprecated` - указывает, что объявление устарело и должно быть заменено более новой формой
- `@SafeVarargs` - аннотация-маркер, применяется к методам и конструкторам. Она указывает, что никакие небезопасные действия, связанные с параметром переменного количества аргументов, недопустимы. Применяется только к методам и конструкторам с переменным количеством аргументов, которые объявлены как `static` или `final`
- `@SuppressWarnings` - эта аннотация указывает, что одно или более предупреждений, которые могут быть выданы компилятором следует подавить
- `@Repeatable` - позволяет использовать множество аннотаций одного типа
- `@FunctionalInterface`- используется для обозначения функционального интерфейса, выдаст ошибку компиляции когда `interface` будет иметь два и более метода


### Создание собственных аннотаций
Аннотации создаются с использование механизма, основанного на интерфейсе. Ниже пример объявление аннотации:
```java
@interface MyAnnotation { 
    String str(); 
    int val(); 
}
```

Символ `@` - указывает компилятору, что объявлена аннотация. Методы, объявленные в аннотации ведут себя скорее как поля.
```java
@MyAnnotation(str = "Пример аннотации", val = 988) 
public static void myMethod() {
    // ... 
}
```

Как видите для аннотирования метода надо за именем аннотации, записать в скобках список инициализируемых членов.

Существует 3 политики удержания аннотации. Политика удержания определяет, в какой точке аннотация сбрасывается.
Такие политики инкапсулированы в перечисление `java.lang.annotation.RetentionPolicy`:
- `SOURCE` - содержаться только в исходном файле и отбрасываются при компиляции
- `CLASS` - сохраняются в файле, однако они недоступны *JVM* во время выполнения
- `RUNTIME` - сохраняются в файле во время компиляции и остаются доступными *JVM* во время выполнения

### Получение аннотации
**Рефлексия** - это средство позволяющее получить информацию о классе во время выполнения программы. Первый шаг в использование рефлексии - это получение объекта `Class`:
```java
Class<?> c = ob.getClass(); 
```

Далее используя объект типа `Class` вы можете получить информацию о различных элементах, объявленных в классе включая аннотацию.

Пример:
```java
Class<?> c = ob.getClass(); 
Method m = c.getMethod("myMethod"); 
MyAnnotation annotation = m.getAnnotation(MyAnnotation.class); 
```

Этот пример использует рефлексию, что бы получить аннотацию `MyAnnotation`, ассоциированную с методом `myMethod()`. В параметры `getMethod()` передается название метода, который мы желаем получить.